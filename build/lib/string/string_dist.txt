在归档文件 libstring.a 中：

string.o：     文件格式 elf64-x86-64
rw-r--r-- 0/0  16360 Jan  1 08:00 1970 string.o
体系结构：i386:x86-64， 标志 0x00000011：
HAS_RELOC, HAS_SYMS
起始地址 0x0000000000000000

节：
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000d6e  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  00000dae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000408  0000000000000000  0000000000000000  00000dc0  2**5
                  ALLOC
  3 .debug_info   000009af  0000000000000000  0000000000000000  00000dc0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  4 .debug_abbrev 00000202  0000000000000000  0000000000000000  0000176f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_aranges 00000030  0000000000000000  0000000000000000  00001971  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  6 .debug_rnglists 00000017  0000000000000000  0000000000000000  000019a1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_line   00000631  0000000000000000  0000000000000000  000019b8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  8 .debug_str    00000229  0000000000000000  0000000000000000  00001fe9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_line_str 000000b9  0000000000000000  0000000000000000  00002212  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .comment      0000002c  0000000000000000  0000000000000000  000022cb  2**0
                  CONTENTS, READONLY
 11 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000022f7  2**0
                  CONTENTS, READONLY
 12 .note.gnu.property 00000020  0000000000000000  0000000000000000  000022f8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 13 .eh_frame     00000218  0000000000000000  0000000000000000  00002318  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
SYMBOL TABLE:
0000000000000000 l    df *ABS*	0000000000000000 string.c
0000000000000000 l    d  .text	0000000000000000 .text
0000000000000000 l    d  .bss	0000000000000000 .bss
0000000000000000 l     O .bss	0000000000000400 cp_src_buf.1
00000000000003db l     F .text	0000000000000135 itoa_with_padding
0000000000000400 l     O .bss	0000000000000008 current_pos.0
0000000000000000 l    d  .debug_info	0000000000000000 .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000 .debug_abbrev
0000000000000000 l    d  .debug_rnglists	0000000000000000 .debug_rnglists
0000000000000000 l    d  .debug_line	0000000000000000 .debug_line
0000000000000000 l    d  .debug_str	0000000000000000 .debug_str
0000000000000000 l    d  .debug_line_str	0000000000000000 .debug_line_str
0000000000000000 g     F .text	0000000000000039 strcpy
0000000000000039 g     F .text	000000000000007d strncpy
00000000000000b6 g     F .text	0000000000000098 strncmp
000000000000014e g     F .text	0000000000000032 strlen
0000000000000180 g     F .text	000000000000005b memcpy
00000000000001db g     F .text	0000000000000061 memmove
000000000000023c g     F .text	0000000000000048 memset
0000000000000284 g     F .text	000000000000008d memcmp
0000000000000311 g     F .text	00000000000000ca itoa
0000000000000510 g     F .text	00000000000000a8 sprintf
0000000000000662 g     F .text	0000000000000281 vsprintf
00000000000005b8 g     F .text	00000000000000aa snprintf
00000000000008e3 g     F .text	000000000000032f vsnprintf
0000000000000c12 g     F .text	0000000000000040 strchr
0000000000000c52 g     F .text	000000000000011c strtok



Disassembly of section .text:

0000000000000000 <strcpy>:
#include "string.h"
#include "types.h"
#include "stdarg.h"
// 字符串拷贝函数 strcpy
void strcpy(char *dest, const char *src) {
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %ebp
   5:	48                   	dec    %eax
   6:	89 e5                	mov    %esp,%ebp
   8:	48                   	dec    %eax
   9:	89 7d f8             	mov    %edi,-0x8(%ebp)
   c:	48                   	dec    %eax
   d:	89 75 f0             	mov    %esi,-0x10(%ebp)
    while ((*dest++ = *src++));
  10:	90                   	nop
  11:	48                   	dec    %eax
  12:	8b 55 f0             	mov    -0x10(%ebp),%edx
  15:	48                   	dec    %eax
  16:	8d 42 01             	lea    0x1(%edx),%eax
  19:	48                   	dec    %eax
  1a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1d:	48                   	dec    %eax
  1e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  21:	48                   	dec    %eax
  22:	8d 48 01             	lea    0x1(%eax),%ecx
  25:	48                   	dec    %eax
  26:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  29:	0f b6 12             	movzbl (%edx),%edx
  2c:	88 10                	mov    %dl,(%eax)
  2e:	0f b6 00             	movzbl (%eax),%eax
  31:	84 c0                	test   %al,%al
  33:	75 dc                	jne    11 <strcpy+0x11>
}
  35:	90                   	nop
  36:	90                   	nop
  37:	5d                   	pop    %ebp
  38:	c3                   	ret    

0000000000000039 <strncpy>:

// 有限长度字符串拷贝函数 strncpy
void strncpy(char *dest, const char *src, int size) {
  39:	f3 0f 1e fa          	endbr64 
  3d:	55                   	push   %ebp
  3e:	48                   	dec    %eax
  3f:	89 e5                	mov    %esp,%ebp
  41:	48                   	dec    %eax
  42:	89 7d e8             	mov    %edi,-0x18(%ebp)
  45:	48                   	dec    %eax
  46:	89 75 e0             	mov    %esi,-0x20(%ebp)
  49:	89 55 dc             	mov    %edx,-0x24(%ebp)
    int i;
    for (i = 0; i < size && src[i] != '\0'; i++) {
  4c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  53:	eb 23                	jmp    78 <strncpy+0x3f>
        dest[i] = src[i];
  55:	8b 45 fc             	mov    -0x4(%ebp),%eax
  58:	48                   	dec    %eax
  59:	63 d0                	arpl   %dx,%ax
  5b:	48                   	dec    %eax
  5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  5f:	48                   	dec    %eax
  60:	01 d0                	add    %edx,%eax
  62:	8b 55 fc             	mov    -0x4(%ebp),%edx
  65:	48                   	dec    %eax
  66:	63 ca                	arpl   %cx,%dx
  68:	48                   	dec    %eax
  69:	8b 55 e8             	mov    -0x18(%ebp),%edx
  6c:	48                   	dec    %eax
  6d:	01 ca                	add    %ecx,%edx
  6f:	0f b6 00             	movzbl (%eax),%eax
  72:	88 02                	mov    %al,(%edx)
    for (i = 0; i < size && src[i] != '\0'; i++) {
  74:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  78:	8b 45 fc             	mov    -0x4(%ebp),%eax
  7b:	3b 45 dc             	cmp    -0x24(%ebp),%eax
  7e:	7d 2a                	jge    aa <strncpy+0x71>
  80:	8b 45 fc             	mov    -0x4(%ebp),%eax
  83:	48                   	dec    %eax
  84:	63 d0                	arpl   %dx,%ax
  86:	48                   	dec    %eax
  87:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8a:	48                   	dec    %eax
  8b:	01 d0                	add    %edx,%eax
  8d:	0f b6 00             	movzbl (%eax),%eax
  90:	84 c0                	test   %al,%al
  92:	75 c1                	jne    55 <strncpy+0x1c>
    }
    for (; i < size; i++) {
  94:	eb 14                	jmp    aa <strncpy+0x71>
        dest[i] = '\0';
  96:	8b 45 fc             	mov    -0x4(%ebp),%eax
  99:	48                   	dec    %eax
  9a:	63 d0                	arpl   %dx,%ax
  9c:	48                   	dec    %eax
  9d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  a0:	48                   	dec    %eax
  a1:	01 d0                	add    %edx,%eax
  a3:	c6 00 00             	movb   $0x0,(%eax)
    for (; i < size; i++) {
  a6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
  ad:	3b 45 dc             	cmp    -0x24(%ebp),%eax
  b0:	7c e4                	jl     96 <strncpy+0x5d>
    }
}
  b2:	90                   	nop
  b3:	90                   	nop
  b4:	5d                   	pop    %ebp
  b5:	c3                   	ret    

00000000000000b6 <strncmp>:

// 有限长度字符串比较函数 strncmp
int strncmp(const char *s1, const char *s2, int size) {
  b6:	f3 0f 1e fa          	endbr64 
  ba:	55                   	push   %ebp
  bb:	48                   	dec    %eax
  bc:	89 e5                	mov    %esp,%ebp
  be:	48                   	dec    %eax
  bf:	89 7d e8             	mov    %edi,-0x18(%ebp)
  c2:	48                   	dec    %eax
  c3:	89 75 e0             	mov    %esi,-0x20(%ebp)
  c6:	89 55 dc             	mov    %edx,-0x24(%ebp)
    for (int i = 0; i < size; i++) {
  c9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  d0:	eb 6d                	jmp    13f <strncmp+0x89>
        if (s1[i] != s2[i]) {
  d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  d5:	48                   	dec    %eax
  d6:	63 d0                	arpl   %dx,%ax
  d8:	48                   	dec    %eax
  d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  dc:	48                   	dec    %eax
  dd:	01 d0                	add    %edx,%eax
  df:	0f b6 10             	movzbl (%eax),%edx
  e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  e5:	48                   	dec    %eax
  e6:	63 c8                	arpl   %cx,%ax
  e8:	48                   	dec    %eax
  e9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  ec:	48                   	dec    %eax
  ed:	01 c8                	add    %ecx,%eax
  ef:	0f b6 00             	movzbl (%eax),%eax
  f2:	38 c2                	cmp    %al,%dl
  f4:	74 2a                	je     120 <strncmp+0x6a>
            return (unsigned char)s1[i] - (unsigned char)s2[i];
  f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  f9:	48                   	dec    %eax
  fa:	63 d0                	arpl   %dx,%ax
  fc:	48                   	dec    %eax
  fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
 100:	48                   	dec    %eax
 101:	01 d0                	add    %edx,%eax
 103:	0f b6 00             	movzbl (%eax),%eax
 106:	0f b6 c0             	movzbl %al,%eax
 109:	8b 55 fc             	mov    -0x4(%ebp),%edx
 10c:	48                   	dec    %eax
 10d:	63 ca                	arpl   %cx,%dx
 10f:	48                   	dec    %eax
 110:	8b 55 e0             	mov    -0x20(%ebp),%edx
 113:	48                   	dec    %eax
 114:	01 ca                	add    %ecx,%edx
 116:	0f b6 12             	movzbl (%edx),%edx
 119:	0f b6 d2             	movzbl %dl,%edx
 11c:	29 d0                	sub    %edx,%eax
 11e:	eb 2c                	jmp    14c <strncmp+0x96>
        }
        if (s1[i] == '\0') {
 120:	8b 45 fc             	mov    -0x4(%ebp),%eax
 123:	48                   	dec    %eax
 124:	63 d0                	arpl   %dx,%ax
 126:	48                   	dec    %eax
 127:	8b 45 e8             	mov    -0x18(%ebp),%eax
 12a:	48                   	dec    %eax
 12b:	01 d0                	add    %edx,%eax
 12d:	0f b6 00             	movzbl (%eax),%eax
 130:	84 c0                	test   %al,%al
 132:	75 07                	jne    13b <strncmp+0x85>
            return 0;
 134:	b8 00 00 00 00       	mov    $0x0,%eax
 139:	eb 11                	jmp    14c <strncmp+0x96>
    for (int i = 0; i < size; i++) {
 13b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 13f:	8b 45 fc             	mov    -0x4(%ebp),%eax
 142:	3b 45 dc             	cmp    -0x24(%ebp),%eax
 145:	7c 8b                	jl     d2 <strncmp+0x1c>
        }
    }
    return 0;
 147:	b8 00 00 00 00       	mov    $0x0,%eax
}
 14c:	5d                   	pop    %ebp
 14d:	c3                   	ret    

000000000000014e <strlen>:

// 字符串长度函数 strlen
int strlen(const char *str) {
 14e:	f3 0f 1e fa          	endbr64 
 152:	55                   	push   %ebp
 153:	48                   	dec    %eax
 154:	89 e5                	mov    %esp,%ebp
 156:	48                   	dec    %eax
 157:	89 7d e8             	mov    %edi,-0x18(%ebp)
    int len = 0;
 15a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    while (str[len] != '\0') {
 161:	eb 04                	jmp    167 <strlen+0x19>
        len++;
 163:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while (str[len] != '\0') {
 167:	8b 45 fc             	mov    -0x4(%ebp),%eax
 16a:	48                   	dec    %eax
 16b:	63 d0                	arpl   %dx,%ax
 16d:	48                   	dec    %eax
 16e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 171:	48                   	dec    %eax
 172:	01 d0                	add    %edx,%eax
 174:	0f b6 00             	movzbl (%eax),%eax
 177:	84 c0                	test   %al,%al
 179:	75 e8                	jne    163 <strlen+0x15>
    }
    return len;
 17b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 17e:	5d                   	pop    %ebp
 17f:	c3                   	ret    

0000000000000180 <memcpy>:

// 内存拷贝函数 memcpy
void memcpy(void *dest, const void *src, int size) {
 180:	f3 0f 1e fa          	endbr64 
 184:	55                   	push   %ebp
 185:	48                   	dec    %eax
 186:	89 e5                	mov    %esp,%ebp
 188:	48                   	dec    %eax
 189:	89 7d d8             	mov    %edi,-0x28(%ebp)
 18c:	48                   	dec    %eax
 18d:	89 75 d0             	mov    %esi,-0x30(%ebp)
 190:	89 55 cc             	mov    %edx,-0x34(%ebp)
    uint8_t *d = dest;
 193:	48                   	dec    %eax
 194:	8b 45 d8             	mov    -0x28(%ebp),%eax
 197:	48                   	dec    %eax
 198:	89 45 f0             	mov    %eax,-0x10(%ebp)
    const uint8_t *s = src;
 19b:	48                   	dec    %eax
 19c:	8b 45 d0             	mov    -0x30(%ebp),%eax
 19f:	48                   	dec    %eax
 1a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for (int i = 0; i < size; i++) {
 1a3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 1aa:	eb 23                	jmp    1cf <memcpy+0x4f>
        d[i] = s[i];
 1ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
 1af:	48                   	dec    %eax
 1b0:	63 d0                	arpl   %dx,%ax
 1b2:	48                   	dec    %eax
 1b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
 1b6:	48                   	dec    %eax
 1b7:	01 d0                	add    %edx,%eax
 1b9:	8b 55 fc             	mov    -0x4(%ebp),%edx
 1bc:	48                   	dec    %eax
 1bd:	63 ca                	arpl   %cx,%dx
 1bf:	48                   	dec    %eax
 1c0:	8b 55 f0             	mov    -0x10(%ebp),%edx
 1c3:	48                   	dec    %eax
 1c4:	01 ca                	add    %ecx,%edx
 1c6:	0f b6 00             	movzbl (%eax),%eax
 1c9:	88 02                	mov    %al,(%edx)
    for (int i = 0; i < size; i++) {
 1cb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 1cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
 1d2:	3b 45 cc             	cmp    -0x34(%ebp),%eax
 1d5:	7c d5                	jl     1ac <memcpy+0x2c>
    }
}
 1d7:	90                   	nop
 1d8:	90                   	nop
 1d9:	5d                   	pop    %ebp
 1da:	c3                   	ret    

00000000000001db <memmove>:

void memmove(void *dest, const void *src, int size)
{
 1db:	f3 0f 1e fa          	endbr64 
 1df:	55                   	push   %ebp
 1e0:	48                   	dec    %eax
 1e1:	89 e5                	mov    %esp,%ebp
 1e3:	48                   	dec    %eax
 1e4:	83 ec 20             	sub    $0x20,%esp
 1e7:	48                   	dec    %eax
 1e8:	89 7d f8             	mov    %edi,-0x8(%ebp)
 1eb:	48                   	dec    %eax
 1ec:	89 75 f0             	mov    %esi,-0x10(%ebp)
 1ef:	89 55 ec             	mov    %edx,-0x14(%ebp)
    static uint8_t cp_src_buf[1024] = {0};
    if(size >1024)
 1f2:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
 1f9:	7f 3e                	jg     239 <memmove+0x5e>
    {
        //dbg_error("memmove size out of boundry\r\n");
        return;
    }
    memset(cp_src_buf,0,1024);
 1fb:	ba 00 04 00 00       	mov    $0x400,%edx
 200:	be 00 00 00 00       	mov    $0x0,%esi
 205:	bf 00 00 00 00       	mov    $0x0,%edi
			206: R_X86_64_32	.bss
 20a:	e8 00 00 00 00       	call   20f <memmove+0x34>
			20b: R_X86_64_PLT32	memset-0x4
    memcpy(cp_src_buf,src,size);
 20f:	8b 55 ec             	mov    -0x14(%ebp),%edx
 212:	48                   	dec    %eax
 213:	8b 45 f0             	mov    -0x10(%ebp),%eax
 216:	48                   	dec    %eax
 217:	89 c6                	mov    %eax,%esi
 219:	bf 00 00 00 00       	mov    $0x0,%edi
			21a: R_X86_64_32	.bss
 21e:	e8 00 00 00 00       	call   223 <memmove+0x48>
			21f: R_X86_64_PLT32	memcpy-0x4
    memcpy(dest,cp_src_buf,size);
 223:	8b 55 ec             	mov    -0x14(%ebp),%edx
 226:	48                   	dec    %eax
 227:	8b 45 f8             	mov    -0x8(%ebp),%eax
 22a:	be 00 00 00 00       	mov    $0x0,%esi
			22b: R_X86_64_32	.bss
 22f:	48                   	dec    %eax
 230:	89 c7                	mov    %eax,%edi
 232:	e8 00 00 00 00       	call   237 <memmove+0x5c>
			233: R_X86_64_PLT32	memcpy-0x4
    return;
 237:	eb 01                	jmp    23a <memmove+0x5f>
        return;
 239:	90                   	nop

}
 23a:	c9                   	leave  
 23b:	c3                   	ret    

000000000000023c <memset>:
// 内存填充函数 memset
void memset(void *dest, uint8_t v, int size) {
 23c:	f3 0f 1e fa          	endbr64 
 240:	55                   	push   %ebp
 241:	48                   	dec    %eax
 242:	89 e5                	mov    %esp,%ebp
 244:	48                   	dec    %eax
 245:	89 7d e8             	mov    %edi,-0x18(%ebp)
 248:	89 f0                	mov    %esi,%eax
 24a:	89 55 e0             	mov    %edx,-0x20(%ebp)
 24d:	88 45 e4             	mov    %al,-0x1c(%ebp)
    uint8_t *d = dest;
 250:	48                   	dec    %eax
 251:	8b 45 e8             	mov    -0x18(%ebp),%eax
 254:	48                   	dec    %eax
 255:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for (int i = 0; i < size; i++) {
 258:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 25f:	eb 17                	jmp    278 <memset+0x3c>
        d[i] = v;
 261:	8b 45 fc             	mov    -0x4(%ebp),%eax
 264:	48                   	dec    %eax
 265:	63 d0                	arpl   %dx,%ax
 267:	48                   	dec    %eax
 268:	8b 45 f0             	mov    -0x10(%ebp),%eax
 26b:	48                   	dec    %eax
 26c:	01 c2                	add    %eax,%edx
 26e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
 272:	88 02                	mov    %al,(%edx)
    for (int i = 0; i < size; i++) {
 274:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 278:	8b 45 fc             	mov    -0x4(%ebp),%eax
 27b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 27e:	7c e1                	jl     261 <memset+0x25>
    }
}
 280:	90                   	nop
 281:	90                   	nop
 282:	5d                   	pop    %ebp
 283:	c3                   	ret    

0000000000000284 <memcmp>:

// 内存比较函数 memcmp
int memcmp(const void *d1, const void *d2, int size) {
 284:	f3 0f 1e fa          	endbr64 
 288:	55                   	push   %ebp
 289:	48                   	dec    %eax
 28a:	89 e5                	mov    %esp,%ebp
 28c:	48                   	dec    %eax
 28d:	89 7d d8             	mov    %edi,-0x28(%ebp)
 290:	48                   	dec    %eax
 291:	89 75 d0             	mov    %esi,-0x30(%ebp)
 294:	89 55 cc             	mov    %edx,-0x34(%ebp)
    const uint8_t *s1 = d1;
 297:	48                   	dec    %eax
 298:	8b 45 d8             	mov    -0x28(%ebp),%eax
 29b:	48                   	dec    %eax
 29c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    const uint8_t *s2 = d2;
 29f:	48                   	dec    %eax
 2a0:	8b 45 d0             	mov    -0x30(%ebp),%eax
 2a3:	48                   	dec    %eax
 2a4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for (int i = 0; i < size; i++) {
 2a7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 2ae:	eb 52                	jmp    302 <memcmp+0x7e>
        if (s1[i] != s2[i]) {
 2b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
 2b3:	48                   	dec    %eax
 2b4:	63 d0                	arpl   %dx,%ax
 2b6:	48                   	dec    %eax
 2b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 2ba:	48                   	dec    %eax
 2bb:	01 d0                	add    %edx,%eax
 2bd:	0f b6 10             	movzbl (%eax),%edx
 2c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
 2c3:	48                   	dec    %eax
 2c4:	63 c8                	arpl   %cx,%ax
 2c6:	48                   	dec    %eax
 2c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 2ca:	48                   	dec    %eax
 2cb:	01 c8                	add    %ecx,%eax
 2cd:	0f b6 00             	movzbl (%eax),%eax
 2d0:	38 c2                	cmp    %al,%dl
 2d2:	74 2a                	je     2fe <memcmp+0x7a>
            return s1[i] - s2[i];
 2d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
 2d7:	48                   	dec    %eax
 2d8:	63 d0                	arpl   %dx,%ax
 2da:	48                   	dec    %eax
 2db:	8b 45 f0             	mov    -0x10(%ebp),%eax
 2de:	48                   	dec    %eax
 2df:	01 d0                	add    %edx,%eax
 2e1:	0f b6 00             	movzbl (%eax),%eax
 2e4:	0f b6 c0             	movzbl %al,%eax
 2e7:	8b 55 fc             	mov    -0x4(%ebp),%edx
 2ea:	48                   	dec    %eax
 2eb:	63 ca                	arpl   %cx,%dx
 2ed:	48                   	dec    %eax
 2ee:	8b 55 e8             	mov    -0x18(%ebp),%edx
 2f1:	48                   	dec    %eax
 2f2:	01 ca                	add    %ecx,%edx
 2f4:	0f b6 12             	movzbl (%edx),%edx
 2f7:	0f b6 d2             	movzbl %dl,%edx
 2fa:	29 d0                	sub    %edx,%eax
 2fc:	eb 11                	jmp    30f <memcmp+0x8b>
    for (int i = 0; i < size; i++) {
 2fe:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 302:	8b 45 fc             	mov    -0x4(%ebp),%eax
 305:	3b 45 cc             	cmp    -0x34(%ebp),%eax
 308:	7c a6                	jl     2b0 <memcmp+0x2c>
        }
    }
    return 0;
 30a:	b8 00 00 00 00       	mov    $0x0,%eax
}
 30f:	5d                   	pop    %ebp
 310:	c3                   	ret    

0000000000000311 <itoa>:

void itoa(char *buf, uint32_t num, int base) {
 311:	f3 0f 1e fa          	endbr64 
 315:	55                   	push   %ebp
 316:	48                   	dec    %eax
 317:	89 e5                	mov    %esp,%ebp
 319:	48                   	dec    %eax
 31a:	89 7d c8             	mov    %edi,-0x38(%ebp)
 31d:	89 75 c4             	mov    %esi,-0x3c(%ebp)
 320:	89 55 c0             	mov    %edx,-0x40(%ebp)
    char *ptr = buf;
 323:	48                   	dec    %eax
 324:	8b 45 c8             	mov    -0x38(%ebp),%eax
 327:	48                   	dec    %eax
 328:	89 45 f8             	mov    %eax,-0x8(%ebp)

    // 临时变量
    uint32_t temp = num;
 32b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 32e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 转换为字符串（低位在前）
    do {
        int remainder = temp % base;
 331:	8b 4d c0             	mov    -0x40(%ebp),%ecx
 334:	8b 45 f4             	mov    -0xc(%ebp),%eax
 337:	ba 00 00 00 00       	mov    $0x0,%edx
 33c:	f7 f1                	div    %ecx
 33e:	89 d0                	mov    %edx,%eax
 340:	89 45 dc             	mov    %eax,-0x24(%ebp)
        *ptr++ = (remainder > 9) ? (remainder - 10) + 'a' : remainder + '0';
 343:	83 7d dc 09          	cmpl   $0x9,-0x24(%ebp)
 347:	7e 0a                	jle    353 <itoa+0x42>
 349:	8b 45 dc             	mov    -0x24(%ebp),%eax
 34c:	83 c0 57             	add    $0x57,%eax
 34f:	89 c1                	mov    %eax,%ecx
 351:	eb 08                	jmp    35b <itoa+0x4a>
 353:	8b 45 dc             	mov    -0x24(%ebp),%eax
 356:	83 c0 30             	add    $0x30,%eax
 359:	89 c1                	mov    %eax,%ecx
 35b:	48                   	dec    %eax
 35c:	8b 45 f8             	mov    -0x8(%ebp),%eax
 35f:	48                   	dec    %eax
 360:	8d 50 01             	lea    0x1(%eax),%edx
 363:	48                   	dec    %eax
 364:	89 55 f8             	mov    %edx,-0x8(%ebp)
 367:	88 08                	mov    %cl,(%eax)
    } while (temp /= base);
 369:	8b 75 c0             	mov    -0x40(%ebp),%esi
 36c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 36f:	ba 00 00 00 00       	mov    $0x0,%edx
 374:	f7 f6                	div    %esi
 376:	89 45 f4             	mov    %eax,-0xc(%ebp)
 379:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 37d:	75 b2                	jne    331 <itoa+0x20>

    // 添加字符串结束符
    *ptr = '\0';
 37f:	48                   	dec    %eax
 380:	8b 45 f8             	mov    -0x8(%ebp),%eax
 383:	c6 00 00             	movb   $0x0,(%eax)

    // 反转字符串
    char *start = buf;
 386:	48                   	dec    %eax
 387:	8b 45 c8             	mov    -0x38(%ebp),%eax
 38a:	48                   	dec    %eax
 38b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    char *end = ptr - 1;
 38e:	48                   	dec    %eax
 38f:	8b 45 f8             	mov    -0x8(%ebp),%eax
 392:	48                   	dec    %eax
 393:	83 e8 01             	sub    $0x1,%eax
 396:	48                   	dec    %eax
 397:	89 45 e0             	mov    %eax,-0x20(%ebp)
    while (start < end) {
 39a:	eb 31                	jmp    3cd <itoa+0xbc>
        char tmp = *start;
 39c:	48                   	dec    %eax
 39d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 3a0:	0f b6 00             	movzbl (%eax),%eax
 3a3:	88 45 db             	mov    %al,-0x25(%ebp)
        *start++ = *end;
 3a6:	48                   	dec    %eax
 3a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
 3aa:	48                   	dec    %eax
 3ab:	8d 50 01             	lea    0x1(%eax),%edx
 3ae:	48                   	dec    %eax
 3af:	89 55 e8             	mov    %edx,-0x18(%ebp)
 3b2:	48                   	dec    %eax
 3b3:	8b 55 e0             	mov    -0x20(%ebp),%edx
 3b6:	0f b6 12             	movzbl (%edx),%edx
 3b9:	88 10                	mov    %dl,(%eax)
        *end-- = tmp;
 3bb:	48                   	dec    %eax
 3bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
 3bf:	48                   	dec    %eax
 3c0:	8d 50 ff             	lea    -0x1(%eax),%edx
 3c3:	48                   	dec    %eax
 3c4:	89 55 e0             	mov    %edx,-0x20(%ebp)
 3c7:	0f b6 55 db          	movzbl -0x25(%ebp),%edx
 3cb:	88 10                	mov    %dl,(%eax)
    while (start < end) {
 3cd:	48                   	dec    %eax
 3ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
 3d1:	48                   	dec    %eax
 3d2:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 3d5:	72 c5                	jb     39c <itoa+0x8b>
    }
}
 3d7:	90                   	nop
 3d8:	90                   	nop
 3d9:	5d                   	pop    %ebp
 3da:	c3                   	ret    

00000000000003db <itoa_with_padding>:


static void itoa_with_padding(char *buf, uint32_t num, int base, int width, int zero_padding) {
 3db:	f3 0f 1e fa          	endbr64 
 3df:	55                   	push   %ebp
 3e0:	48                   	dec    %eax
 3e1:	89 e5                	mov    %esp,%ebp
 3e3:	48                   	dec    %eax
 3e4:	89 7d b8             	mov    %edi,-0x48(%ebp)
 3e7:	89 75 b4             	mov    %esi,-0x4c(%ebp)
 3ea:	89 55 b0             	mov    %edx,-0x50(%ebp)
 3ed:	89 4d ac             	mov    %ecx,-0x54(%ebp)
 3f0:	44                   	inc    %esp
 3f1:	89 45 a8             	mov    %eax,-0x58(%ebp)
    char temp[32];
    char *ptr = temp;
 3f4:	48                   	dec    %eax
 3f5:	8d 45 c0             	lea    -0x40(%ebp),%eax
 3f8:	48                   	dec    %eax
 3f9:	89 45 f8             	mov    %eax,-0x8(%ebp)

    // 特殊情况：num == 0
    if (num == 0) {
 3fc:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
 400:	75 59                	jne    45b <itoa_with_padding+0x80>
        *ptr++ = '0';
 402:	48                   	dec    %eax
 403:	8b 45 f8             	mov    -0x8(%ebp),%eax
 406:	48                   	dec    %eax
 407:	8d 50 01             	lea    0x1(%eax),%edx
 40a:	48                   	dec    %eax
 40b:	89 55 f8             	mov    %edx,-0x8(%ebp)
 40e:	c6 00 30             	movb   $0x30,(%eax)
 411:	eb 4e                	jmp    461 <itoa_with_padding+0x86>
    } else {
        while (num > 0) {
            int remainder = num % base;
 413:	8b 4d b0             	mov    -0x50(%ebp),%ecx
 416:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 419:	ba 00 00 00 00       	mov    $0x0,%edx
 41e:	f7 f1                	div    %ecx
 420:	89 d0                	mov    %edx,%eax
 422:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            *ptr++ = (remainder > 9) ? (remainder - 10) + 'a' : remainder + '0';
 425:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
 429:	7e 0a                	jle    435 <itoa_with_padding+0x5a>
 42b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 42e:	83 c0 57             	add    $0x57,%eax
 431:	89 c1                	mov    %eax,%ecx
 433:	eb 08                	jmp    43d <itoa_with_padding+0x62>
 435:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 438:	83 c0 30             	add    $0x30,%eax
 43b:	89 c1                	mov    %eax,%ecx
 43d:	48                   	dec    %eax
 43e:	8b 45 f8             	mov    -0x8(%ebp),%eax
 441:	48                   	dec    %eax
 442:	8d 50 01             	lea    0x1(%eax),%edx
 445:	48                   	dec    %eax
 446:	89 55 f8             	mov    %edx,-0x8(%ebp)
 449:	88 08                	mov    %cl,(%eax)
            num /= base;
 44b:	8b 75 b0             	mov    -0x50(%ebp),%esi
 44e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 451:	ba 00 00 00 00       	mov    $0x0,%edx
 456:	f7 f6                	div    %esi
 458:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        while (num > 0) {
 45b:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
 45f:	75 b2                	jne    413 <itoa_with_padding+0x38>
        }
    }
    *ptr = '\0';
 461:	48                   	dec    %eax
 462:	8b 45 f8             	mov    -0x8(%ebp),%eax
 465:	c6 00 00             	movb   $0x0,(%eax)

    // 计算实际长度
    int len = ptr - temp;
 468:	48                   	dec    %eax
 469:	8d 55 c0             	lea    -0x40(%ebp),%edx
 46c:	48                   	dec    %eax
 46d:	8b 45 f8             	mov    -0x8(%ebp),%eax
 470:	48                   	dec    %eax
 471:	29 d0                	sub    %edx,%eax
 473:	89 45 e0             	mov    %eax,-0x20(%ebp)
    int pad_len = width > len ? width - len : 0;
 476:	8b 45 ac             	mov    -0x54(%ebp),%eax
 479:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 47c:	7e 08                	jle    486 <itoa_with_padding+0xab>
 47e:	8b 45 ac             	mov    -0x54(%ebp),%eax
 481:	2b 45 e0             	sub    -0x20(%ebp),%eax
 484:	eb 05                	jmp    48b <itoa_with_padding+0xb0>
 486:	b8 00 00 00 00       	mov    $0x0,%eax
 48b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 填充零或空格
    char *buf_ptr = buf;
 48e:	48                   	dec    %eax
 48f:	8b 45 b8             	mov    -0x48(%ebp),%eax
 492:	48                   	dec    %eax
 493:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (zero_padding) {
 496:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
 49a:	74 2f                	je     4cb <itoa_with_padding+0xf0>
        while (pad_len-- > 0) {
 49c:	eb 0f                	jmp    4ad <itoa_with_padding+0xd2>
            *buf_ptr++ = '0';
 49e:	48                   	dec    %eax
 49f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 4a2:	48                   	dec    %eax
 4a3:	8d 50 01             	lea    0x1(%eax),%edx
 4a6:	48                   	dec    %eax
 4a7:	89 55 e8             	mov    %edx,-0x18(%ebp)
 4aa:	c6 00 30             	movb   $0x30,(%eax)
        while (pad_len-- > 0) {
 4ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
 4b0:	8d 50 ff             	lea    -0x1(%eax),%edx
 4b3:	89 55 f4             	mov    %edx,-0xc(%ebp)
 4b6:	85 c0                	test   %eax,%eax
 4b8:	7f e4                	jg     49e <itoa_with_padding+0xc3>
 4ba:	eb 1c                	jmp    4d8 <itoa_with_padding+0xfd>
        }
    } else {
        while (pad_len-- > 0) {
            *buf_ptr++ = ' ';
 4bc:	48                   	dec    %eax
 4bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
 4c0:	48                   	dec    %eax
 4c1:	8d 50 01             	lea    0x1(%eax),%edx
 4c4:	48                   	dec    %eax
 4c5:	89 55 e8             	mov    %edx,-0x18(%ebp)
 4c8:	c6 00 20             	movb   $0x20,(%eax)
        while (pad_len-- > 0) {
 4cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
 4ce:	8d 50 ff             	lea    -0x1(%eax),%edx
 4d1:	89 55 f4             	mov    %edx,-0xc(%ebp)
 4d4:	85 c0                	test   %eax,%eax
 4d6:	7f e4                	jg     4bc <itoa_with_padding+0xe1>
        }
    }

    // 反转字符串并复制到目标缓冲区
    ptr--;
 4d8:	48                   	dec    %eax
 4d9:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
    while (ptr >= temp) {
 4dd:	eb 1d                	jmp    4fc <itoa_with_padding+0x121>
        *buf_ptr++ = *ptr--;
 4df:	48                   	dec    %eax
 4e0:	8b 55 f8             	mov    -0x8(%ebp),%edx
 4e3:	48                   	dec    %eax
 4e4:	8d 42 ff             	lea    -0x1(%edx),%eax
 4e7:	48                   	dec    %eax
 4e8:	89 45 f8             	mov    %eax,-0x8(%ebp)
 4eb:	48                   	dec    %eax
 4ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
 4ef:	48                   	dec    %eax
 4f0:	8d 48 01             	lea    0x1(%eax),%ecx
 4f3:	48                   	dec    %eax
 4f4:	89 4d e8             	mov    %ecx,-0x18(%ebp)
 4f7:	0f b6 12             	movzbl (%edx),%edx
 4fa:	88 10                	mov    %dl,(%eax)
    while (ptr >= temp) {
 4fc:	48                   	dec    %eax
 4fd:	8d 45 c0             	lea    -0x40(%ebp),%eax
 500:	48                   	dec    %eax
 501:	39 45 f8             	cmp    %eax,-0x8(%ebp)
 504:	73 d9                	jae    4df <itoa_with_padding+0x104>
    }

    *buf_ptr = '\0'; // 添加字符串结束符
 506:	48                   	dec    %eax
 507:	8b 45 e8             	mov    -0x18(%ebp),%eax
 50a:	c6 00 00             	movb   $0x0,(%eax)
}
 50d:	90                   	nop
 50e:	5d                   	pop    %ebp
 50f:	c3                   	ret    

0000000000000510 <sprintf>:

int sprintf(char *buffer, const char *fmt, ...) {
 510:	f3 0f 1e fa          	endbr64 
 514:	55                   	push   %ebp
 515:	48                   	dec    %eax
 516:	89 e5                	mov    %esp,%ebp
 518:	48                   	dec    %eax
 519:	81 ec d0 00 00 00    	sub    $0xd0,%esp
 51f:	48                   	dec    %eax
 520:	89 bd 38 ff ff ff    	mov    %edi,-0xc8(%ebp)
 526:	48                   	dec    %eax
 527:	89 b5 30 ff ff ff    	mov    %esi,-0xd0(%ebp)
 52d:	48                   	dec    %eax
 52e:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
 534:	48                   	dec    %eax
 535:	89 8d 68 ff ff ff    	mov    %ecx,-0x98(%ebp)
 53b:	4c                   	dec    %esp
 53c:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
 542:	4c                   	dec    %esp
 543:	89 8d 78 ff ff ff    	mov    %ecx,-0x88(%ebp)
 549:	84 c0                	test   %al,%al
 54b:	74 20                	je     56d <sprintf+0x5d>
 54d:	0f 29 45 80          	movaps %xmm0,-0x80(%ebp)
 551:	0f 29 4d 90          	movaps %xmm1,-0x70(%ebp)
 555:	0f 29 55 a0          	movaps %xmm2,-0x60(%ebp)
 559:	0f 29 5d b0          	movaps %xmm3,-0x50(%ebp)
 55d:	0f 29 65 c0          	movaps %xmm4,-0x40(%ebp)
 561:	0f 29 6d d0          	movaps %xmm5,-0x30(%ebp)
 565:	0f 29 75 e0          	movaps %xmm6,-0x20(%ebp)
 569:	0f 29 7d f0          	movaps %xmm7,-0x10(%ebp)
    int ret;
    va_list args;
    va_start(args, fmt);
 56d:	48                   	dec    %eax
 56e:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
 574:	48                   	dec    %eax
 575:	83 c0 08             	add    $0x8,%eax
 578:	48                   	dec    %eax
 579:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
    ret = vsprintf(buffer, fmt, args);
 57f:	48                   	dec    %eax
 580:	8b 8d 30 ff ff ff    	mov    -0xd0(%ebp),%ecx
 586:	48                   	dec    %eax
 587:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
 58d:	48                   	dec    %eax
 58e:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
 594:	48                   	dec    %eax
 595:	89 ce                	mov    %ecx,%esi
 597:	48                   	dec    %eax
 598:	89 c7                	mov    %eax,%edi
 59a:	e8 00 00 00 00       	call   59f <sprintf+0x8f>
			59b: R_X86_64_PLT32	vsprintf-0x4
 59f:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
    va_end(args);
 5a5:	48                   	dec    %eax
 5a6:	c7 85 48 ff ff ff 00 	movl   $0x0,-0xb8(%ebp)
 5ad:	00 00 00 
    return ret;
 5b0:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
}
 5b6:	c9                   	leave  
 5b7:	c3                   	ret    

00000000000005b8 <snprintf>:
int snprintf(char * buffer, int buf_size,const char * fmt, ...){
 5b8:	f3 0f 1e fa          	endbr64 
 5bc:	55                   	push   %ebp
 5bd:	48                   	dec    %eax
 5be:	89 e5                	mov    %esp,%ebp
 5c0:	48                   	dec    %eax
 5c1:	81 ec e0 00 00 00    	sub    $0xe0,%esp
 5c7:	48                   	dec    %eax
 5c8:	89 bd 38 ff ff ff    	mov    %edi,-0xc8(%ebp)
 5ce:	89 b5 34 ff ff ff    	mov    %esi,-0xcc(%ebp)
 5d4:	48                   	dec    %eax
 5d5:	89 95 28 ff ff ff    	mov    %edx,-0xd8(%ebp)
 5db:	48                   	dec    %eax
 5dc:	89 8d 68 ff ff ff    	mov    %ecx,-0x98(%ebp)
 5e2:	4c                   	dec    %esp
 5e3:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
 5e9:	4c                   	dec    %esp
 5ea:	89 8d 78 ff ff ff    	mov    %ecx,-0x88(%ebp)
 5f0:	84 c0                	test   %al,%al
 5f2:	74 20                	je     614 <snprintf+0x5c>
 5f4:	0f 29 45 80          	movaps %xmm0,-0x80(%ebp)
 5f8:	0f 29 4d 90          	movaps %xmm1,-0x70(%ebp)
 5fc:	0f 29 55 a0          	movaps %xmm2,-0x60(%ebp)
 600:	0f 29 5d b0          	movaps %xmm3,-0x50(%ebp)
 604:	0f 29 65 c0          	movaps %xmm4,-0x40(%ebp)
 608:	0f 29 6d d0          	movaps %xmm5,-0x30(%ebp)
 60c:	0f 29 75 e0          	movaps %xmm6,-0x20(%ebp)
 610:	0f 29 7d f0          	movaps %xmm7,-0x10(%ebp)
    int ret;
    va_list args;
    va_start(args, fmt);
 614:	48                   	dec    %eax
 615:	8d 85 28 ff ff ff    	lea    -0xd8(%ebp),%eax
 61b:	48                   	dec    %eax
 61c:	83 c0 08             	add    $0x8,%eax
 61f:	48                   	dec    %eax
 620:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
    ret = vsnprintf(buffer, buf_size,fmt, args);
 626:	48                   	dec    %eax
 627:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
 62d:	48                   	dec    %eax
 62e:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
 634:	8b b5 34 ff ff ff    	mov    -0xcc(%ebp),%esi
 63a:	48                   	dec    %eax
 63b:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
 641:	48                   	dec    %eax
 642:	89 c7                	mov    %eax,%edi
 644:	e8 00 00 00 00       	call   649 <snprintf+0x91>
			645: R_X86_64_PLT32	vsnprintf-0x4
 649:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
    va_end(args);
 64f:	48                   	dec    %eax
 650:	c7 85 48 ff ff ff 00 	movl   $0x0,-0xb8(%ebp)
 657:	00 00 00 
    return ret;
 65a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
}
 660:	c9                   	leave  
 661:	c3                   	ret    

0000000000000662 <vsprintf>:


int vsprintf(char *buffer, const char *fmt, va_list args) {
 662:	f3 0f 1e fa          	endbr64 
 666:	55                   	push   %ebp
 667:	48                   	dec    %eax
 668:	89 e5                	mov    %esp,%ebp
 66a:	48                   	dec    %eax
 66b:	83 ec 70             	sub    $0x70,%esp
 66e:	48                   	dec    %eax
 66f:	89 7d a8             	mov    %edi,-0x58(%ebp)
 672:	48                   	dec    %eax
 673:	89 75 a0             	mov    %esi,-0x60(%ebp)
 676:	48                   	dec    %eax
 677:	89 55 98             	mov    %edx,-0x68(%ebp)
    char *buf_ptr = buffer;
 67a:	48                   	dec    %eax
 67b:	8b 45 a8             	mov    -0x58(%ebp),%eax
 67e:	48                   	dec    %eax
 67f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    const char *fmt_ptr = fmt;
 682:	48                   	dec    %eax
 683:	8b 45 a0             	mov    -0x60(%ebp),%eax
 686:	48                   	dec    %eax
 687:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (*fmt_ptr) {
 68a:	e9 34 02 00 00       	jmp    8c3 <vsprintf+0x261>
        if (*fmt_ptr == '%' && *(fmt_ptr + 1) != '%') {
 68f:	48                   	dec    %eax
 690:	8b 45 f0             	mov    -0x10(%ebp),%eax
 693:	0f b6 00             	movzbl (%eax),%eax
 696:	3c 25                	cmp    $0x25,%al
 698:	0f 85 0b 02 00 00    	jne    8a9 <vsprintf+0x247>
 69e:	48                   	dec    %eax
 69f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 6a2:	48                   	dec    %eax
 6a3:	83 c0 01             	add    $0x1,%eax
 6a6:	0f b6 00             	movzbl (%eax),%eax
 6a9:	3c 25                	cmp    $0x25,%al
 6ab:	0f 84 f8 01 00 00    	je     8a9 <vsprintf+0x247>
            fmt_ptr++;  // 跳过 '%'
 6b1:	48                   	dec    %eax
 6b2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

            // 解析宽度和填充
            int width = 0;
 6b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
            int zero_padding = 0;
 6bd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            if (*fmt_ptr == '0') {
 6c4:	48                   	dec    %eax
 6c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 6c8:	0f b6 00             	movzbl (%eax),%eax
 6cb:	3c 30                	cmp    $0x30,%al
 6cd:	75 33                	jne    702 <vsprintf+0xa0>
                zero_padding = 1;
 6cf:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
                fmt_ptr++;
 6d6:	48                   	dec    %eax
 6d7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            }
            while (*fmt_ptr >= '0' && *fmt_ptr <= '9') {
 6db:	eb 25                	jmp    702 <vsprintf+0xa0>
                width = width * 10 + (*fmt_ptr - '0');
 6dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
 6e0:	89 d0                	mov    %edx,%eax
 6e2:	c1 e0 02             	shl    $0x2,%eax
 6e5:	01 d0                	add    %edx,%eax
 6e7:	01 c0                	add    %eax,%eax
 6e9:	89 c2                	mov    %eax,%edx
 6eb:	48                   	dec    %eax
 6ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
 6ef:	0f b6 00             	movzbl (%eax),%eax
 6f2:	0f be c0             	movsbl %al,%eax
 6f5:	83 e8 30             	sub    $0x30,%eax
 6f8:	01 d0                	add    %edx,%eax
 6fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
                fmt_ptr++;
 6fd:	48                   	dec    %eax
 6fe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            while (*fmt_ptr >= '0' && *fmt_ptr <= '9') {
 702:	48                   	dec    %eax
 703:	8b 45 f0             	mov    -0x10(%ebp),%eax
 706:	0f b6 00             	movzbl (%eax),%eax
 709:	3c 2f                	cmp    $0x2f,%al
 70b:	7e 0b                	jle    718 <vsprintf+0xb6>
 70d:	48                   	dec    %eax
 70e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 711:	0f b6 00             	movzbl (%eax),%eax
 714:	3c 39                	cmp    $0x39,%al
 716:	7e c5                	jle    6dd <vsprintf+0x7b>
            }

            // 解析格式化符号
            switch (*fmt_ptr) {
 718:	48                   	dec    %eax
 719:	8b 45 f0             	mov    -0x10(%ebp),%eax
 71c:	0f b6 00             	movzbl (%eax),%eax
 71f:	0f be c0             	movsbl %al,%eax
 722:	83 f8 78             	cmp    $0x78,%eax
 725:	0f 84 85 00 00 00    	je     7b0 <vsprintf+0x14e>
 72b:	83 f8 78             	cmp    $0x78,%eax
 72e:	0f 8f 5d 01 00 00    	jg     891 <vsprintf+0x22f>
 734:	83 f8 73             	cmp    $0x73,%eax
 737:	0f 84 cb 00 00 00    	je     808 <vsprintf+0x1a6>
 73d:	83 f8 73             	cmp    $0x73,%eax
 740:	0f 8f 4b 01 00 00    	jg     891 <vsprintf+0x22f>
 746:	83 f8 63             	cmp    $0x63,%eax
 749:	0f 84 1c 01 00 00    	je     86b <vsprintf+0x209>
 74f:	83 f8 64             	cmp    $0x64,%eax
 752:	0f 85 39 01 00 00    	jne    891 <vsprintf+0x22f>
                case 'd': {
                    int num = va_arg(args, int);
 758:	48                   	dec    %eax
 759:	83 45 98 08          	addl   $0x8,-0x68(%ebp)
 75d:	48                   	dec    %eax
 75e:	8b 45 98             	mov    -0x68(%ebp),%eax
 761:	8b 40 f8             	mov    -0x8(%eax),%eax
 764:	89 45 d4             	mov    %eax,-0x2c(%ebp)
                    char temp_buf[32];
                    itoa_with_padding(temp_buf, num, 10, width, zero_padding);
 767:	8b 75 d4             	mov    -0x2c(%ebp),%esi
 76a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 76d:	8b 55 ec             	mov    -0x14(%ebp),%edx
 770:	48                   	dec    %eax
 771:	8d 45 b0             	lea    -0x50(%ebp),%eax
 774:	41                   	inc    %ecx
 775:	89 c8                	mov    %ecx,%eax
 777:	89 d1                	mov    %edx,%ecx
 779:	ba 0a 00 00 00       	mov    $0xa,%edx
 77e:	48                   	dec    %eax
 77f:	89 c7                	mov    %eax,%edi
 781:	e8 55 fc ff ff       	call   3db <itoa_with_padding>
                    strcpy(buf_ptr, temp_buf);
 786:	48                   	dec    %eax
 787:	8d 55 b0             	lea    -0x50(%ebp),%edx
 78a:	48                   	dec    %eax
 78b:	8b 45 f8             	mov    -0x8(%ebp),%eax
 78e:	48                   	dec    %eax
 78f:	89 d6                	mov    %edx,%esi
 791:	48                   	dec    %eax
 792:	89 c7                	mov    %eax,%edi
 794:	e8 00 00 00 00       	call   799 <vsprintf+0x137>
			795: R_X86_64_PLT32	strcpy-0x4
                    buf_ptr += strlen(temp_buf);
 799:	48                   	dec    %eax
 79a:	8d 45 b0             	lea    -0x50(%ebp),%eax
 79d:	48                   	dec    %eax
 79e:	89 c7                	mov    %eax,%edi
 7a0:	e8 00 00 00 00       	call   7a5 <vsprintf+0x143>
			7a1: R_X86_64_PLT32	strlen-0x4
 7a5:	48                   	dec    %eax
 7a6:	98                   	cwtl   
 7a7:	48                   	dec    %eax
 7a8:	01 45 f8             	add    %eax,-0x8(%ebp)
                    break;
 7ab:	e9 f7 00 00 00       	jmp    8a7 <vsprintf+0x245>
                }
                case 'x': {
                    unsigned int num = va_arg(args, unsigned int);
 7b0:	48                   	dec    %eax
 7b1:	83 45 98 08          	addl   $0x8,-0x68(%ebp)
 7b5:	48                   	dec    %eax
 7b6:	8b 45 98             	mov    -0x68(%ebp),%eax
 7b9:	8b 40 f8             	mov    -0x8(%eax),%eax
 7bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    char temp_buf[32];
                    itoa_with_padding(temp_buf, num, 16, width, zero_padding);
 7bf:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 7c2:	8b 55 ec             	mov    -0x14(%ebp),%edx
 7c5:	8b 75 e0             	mov    -0x20(%ebp),%esi
 7c8:	48                   	dec    %eax
 7c9:	8d 45 b0             	lea    -0x50(%ebp),%eax
 7cc:	41                   	inc    %ecx
 7cd:	89 c8                	mov    %ecx,%eax
 7cf:	89 d1                	mov    %edx,%ecx
 7d1:	ba 10 00 00 00       	mov    $0x10,%edx
 7d6:	48                   	dec    %eax
 7d7:	89 c7                	mov    %eax,%edi
 7d9:	e8 fd fb ff ff       	call   3db <itoa_with_padding>
                    strcpy(buf_ptr, temp_buf);
 7de:	48                   	dec    %eax
 7df:	8d 55 b0             	lea    -0x50(%ebp),%edx
 7e2:	48                   	dec    %eax
 7e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
 7e6:	48                   	dec    %eax
 7e7:	89 d6                	mov    %edx,%esi
 7e9:	48                   	dec    %eax
 7ea:	89 c7                	mov    %eax,%edi
 7ec:	e8 00 00 00 00       	call   7f1 <vsprintf+0x18f>
			7ed: R_X86_64_PLT32	strcpy-0x4
                    buf_ptr += strlen(temp_buf);
 7f1:	48                   	dec    %eax
 7f2:	8d 45 b0             	lea    -0x50(%ebp),%eax
 7f5:	48                   	dec    %eax
 7f6:	89 c7                	mov    %eax,%edi
 7f8:	e8 00 00 00 00       	call   7fd <vsprintf+0x19b>
			7f9: R_X86_64_PLT32	strlen-0x4
 7fd:	48                   	dec    %eax
 7fe:	98                   	cwtl   
 7ff:	48                   	dec    %eax
 800:	01 45 f8             	add    %eax,-0x8(%ebp)
                    break;
 803:	e9 9f 00 00 00       	jmp    8a7 <vsprintf+0x245>
                }
                case 's': {
                    const char *str = va_arg(args, const char *);
 808:	48                   	dec    %eax
 809:	83 45 98 08          	addl   $0x8,-0x68(%ebp)
 80d:	48                   	dec    %eax
 80e:	8b 45 98             	mov    -0x68(%ebp),%eax
 811:	48                   	dec    %eax
 812:	8b 40 f8             	mov    -0x8(%eax),%eax
 815:	48                   	dec    %eax
 816:	89 45 d8             	mov    %eax,-0x28(%ebp)
                    int len = strlen(str);
 819:	48                   	dec    %eax
 81a:	8b 45 d8             	mov    -0x28(%ebp),%eax
 81d:	48                   	dec    %eax
 81e:	89 c7                	mov    %eax,%edi
 820:	e8 00 00 00 00       	call   825 <vsprintf+0x1c3>
			821: R_X86_64_PLT32	strlen-0x4
 825:	89 45 e4             	mov    %eax,-0x1c(%ebp)

                    // 填充宽度
                    if (width > len) {
 828:	8b 45 ec             	mov    -0x14(%ebp),%eax
 82b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 82e:	7e 1d                	jle    84d <vsprintf+0x1eb>
                        while (len < width) {
 830:	eb 13                	jmp    845 <vsprintf+0x1e3>
                            *buf_ptr++ = ' ';
 832:	48                   	dec    %eax
 833:	8b 45 f8             	mov    -0x8(%ebp),%eax
 836:	48                   	dec    %eax
 837:	8d 50 01             	lea    0x1(%eax),%edx
 83a:	48                   	dec    %eax
 83b:	89 55 f8             	mov    %edx,-0x8(%ebp)
 83e:	c6 00 20             	movb   $0x20,(%eax)
                            len++;
 841:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
                        while (len < width) {
 845:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 848:	3b 45 ec             	cmp    -0x14(%ebp),%eax
 84b:	7c e5                	jl     832 <vsprintf+0x1d0>
                        }
                    }
                    strcpy(buf_ptr, str);
 84d:	48                   	dec    %eax
 84e:	8b 55 d8             	mov    -0x28(%ebp),%edx
 851:	48                   	dec    %eax
 852:	8b 45 f8             	mov    -0x8(%ebp),%eax
 855:	48                   	dec    %eax
 856:	89 d6                	mov    %edx,%esi
 858:	48                   	dec    %eax
 859:	89 c7                	mov    %eax,%edi
 85b:	e8 00 00 00 00       	call   860 <vsprintf+0x1fe>
			85c: R_X86_64_PLT32	strcpy-0x4
                    buf_ptr += len;
 860:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 863:	48                   	dec    %eax
 864:	98                   	cwtl   
 865:	48                   	dec    %eax
 866:	01 45 f8             	add    %eax,-0x8(%ebp)
                    break;
 869:	eb 3c                	jmp    8a7 <vsprintf+0x245>
                }
                case 'c': {
                    char c = (char) va_arg(args, int);
 86b:	48                   	dec    %eax
 86c:	83 45 98 08          	addl   $0x8,-0x68(%ebp)
 870:	48                   	dec    %eax
 871:	8b 45 98             	mov    -0x68(%ebp),%eax
 874:	48                   	dec    %eax
 875:	83 e8 08             	sub    $0x8,%eax
 878:	8b 00                	mov    (%eax),%eax
 87a:	88 45 d3             	mov    %al,-0x2d(%ebp)
                    *buf_ptr++ = c;
 87d:	48                   	dec    %eax
 87e:	8b 45 f8             	mov    -0x8(%ebp),%eax
 881:	48                   	dec    %eax
 882:	8d 50 01             	lea    0x1(%eax),%edx
 885:	48                   	dec    %eax
 886:	89 55 f8             	mov    %edx,-0x8(%ebp)
 889:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
 88d:	88 10                	mov    %dl,(%eax)
                    break;
 88f:	eb 16                	jmp    8a7 <vsprintf+0x245>
                }
                default: {
                    *buf_ptr++ = *fmt_ptr;
 891:	48                   	dec    %eax
 892:	8b 45 f8             	mov    -0x8(%ebp),%eax
 895:	48                   	dec    %eax
 896:	8d 50 01             	lea    0x1(%eax),%edx
 899:	48                   	dec    %eax
 89a:	89 55 f8             	mov    %edx,-0x8(%ebp)
 89d:	48                   	dec    %eax
 89e:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8a1:	0f b6 12             	movzbl (%edx),%edx
 8a4:	88 10                	mov    %dl,(%eax)
                    break;
 8a6:	90                   	nop
        if (*fmt_ptr == '%' && *(fmt_ptr + 1) != '%') {
 8a7:	eb 15                	jmp    8be <vsprintf+0x25c>
                }
            }
        } else {
            *buf_ptr++ = *fmt_ptr;
 8a9:	48                   	dec    %eax
 8aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8ad:	48                   	dec    %eax
 8ae:	8d 50 01             	lea    0x1(%eax),%edx
 8b1:	48                   	dec    %eax
 8b2:	89 55 f8             	mov    %edx,-0x8(%ebp)
 8b5:	48                   	dec    %eax
 8b6:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8b9:	0f b6 12             	movzbl (%edx),%edx
 8bc:	88 10                	mov    %dl,(%eax)
        }
        fmt_ptr++;
 8be:	48                   	dec    %eax
 8bf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while (*fmt_ptr) {
 8c3:	48                   	dec    %eax
 8c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8c7:	0f b6 00             	movzbl (%eax),%eax
 8ca:	84 c0                	test   %al,%al
 8cc:	0f 85 bd fd ff ff    	jne    68f <vsprintf+0x2d>
    }

    *buf_ptr = '\0'; // 确保字符串以 NULL 结尾
 8d2:	48                   	dec    %eax
 8d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8d6:	c6 00 00             	movb   $0x0,(%eax)

    // 返回写入缓冲区的字节数
    return (int)(buf_ptr - buffer);
 8d9:	48                   	dec    %eax
 8da:	8b 45 f8             	mov    -0x8(%ebp),%eax
 8dd:	48                   	dec    %eax
 8de:	2b 45 a8             	sub    -0x58(%ebp),%eax
}
 8e1:	c9                   	leave  
 8e2:	c3                   	ret    

00000000000008e3 <vsnprintf>:
int vsnprintf(char * buffer, int buf_len,const char * fmt, va_list args){
 8e3:	f3 0f 1e fa          	endbr64 
 8e7:	55                   	push   %ebp
 8e8:	48                   	dec    %eax
 8e9:	89 e5                	mov    %esp,%ebp
 8eb:	48                   	dec    %eax
 8ec:	83 c4 80             	add    $0xffffff80,%esp
 8ef:	48                   	dec    %eax
 8f0:	89 7d 98             	mov    %edi,-0x68(%ebp)
 8f3:	89 75 94             	mov    %esi,-0x6c(%ebp)
 8f6:	48                   	dec    %eax
 8f7:	89 55 88             	mov    %edx,-0x78(%ebp)
 8fa:	48                   	dec    %eax
 8fb:	89 4d 80             	mov    %ecx,-0x80(%ebp)
    if (buffer == NULL || fmt == NULL || buf_len <= 0) {
 8fe:	48                   	dec    %eax
 8ff:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
 903:	74 0d                	je     912 <vsnprintf+0x2f>
 905:	48                   	dec    %eax
 906:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
 90a:	74 06                	je     912 <vsnprintf+0x2f>
 90c:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
 910:	7f 0a                	jg     91c <vsnprintf+0x39>
        return -1;  // 参数检查
 912:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 917:	e9 f4 02 00 00       	jmp    c10 <vsnprintf+0x32d>
    }

    char *buf_ptr = buffer;
 91c:	48                   	dec    %eax
 91d:	8b 45 98             	mov    -0x68(%ebp),%eax
 920:	48                   	dec    %eax
 921:	89 45 f8             	mov    %eax,-0x8(%ebp)
    const char *fmt_ptr = fmt;
 924:	48                   	dec    %eax
 925:	8b 45 88             	mov    -0x78(%ebp),%eax
 928:	48                   	dec    %eax
 929:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int remaining = buf_len - 1;  // 剩余可用空间（为终止符预留）
 92c:	8b 45 94             	mov    -0x6c(%ebp),%eax
 92f:	83 e8 01             	sub    $0x1,%eax
 932:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (*fmt_ptr && remaining > 0) {
 935:	e9 b2 02 00 00       	jmp    bec <vsnprintf+0x309>
        if (*fmt_ptr == '%' && *(fmt_ptr + 1) != '%') {
 93a:	48                   	dec    %eax
 93b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 93e:	0f b6 00             	movzbl (%eax),%eax
 941:	3c 25                	cmp    $0x25,%al
 943:	0f 85 7f 02 00 00    	jne    bc8 <vsnprintf+0x2e5>
 949:	48                   	dec    %eax
 94a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 94d:	48                   	dec    %eax
 94e:	83 c0 01             	add    $0x1,%eax
 951:	0f b6 00             	movzbl (%eax),%eax
 954:	3c 25                	cmp    $0x25,%al
 956:	0f 84 6c 02 00 00    	je     bc8 <vsnprintf+0x2e5>
            fmt_ptr++;  // 跳过 '%'
 95c:	48                   	dec    %eax
 95d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

            // 解析宽度和填充
            int width = 0;
 961:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
            int zero_padding = 0;
 968:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
            if (*fmt_ptr == '0') {
 96f:	48                   	dec    %eax
 970:	8b 45 f0             	mov    -0x10(%ebp),%eax
 973:	0f b6 00             	movzbl (%eax),%eax
 976:	3c 30                	cmp    $0x30,%al
 978:	75 33                	jne    9ad <vsnprintf+0xca>
                zero_padding = 1;
 97a:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
                fmt_ptr++;
 981:	48                   	dec    %eax
 982:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            }
            while (*fmt_ptr >= '0' && *fmt_ptr <= '9') {
 986:	eb 25                	jmp    9ad <vsnprintf+0xca>
                width = width * 10 + (*fmt_ptr - '0');
 988:	8b 55 e8             	mov    -0x18(%ebp),%edx
 98b:	89 d0                	mov    %edx,%eax
 98d:	c1 e0 02             	shl    $0x2,%eax
 990:	01 d0                	add    %edx,%eax
 992:	01 c0                	add    %eax,%eax
 994:	89 c2                	mov    %eax,%edx
 996:	48                   	dec    %eax
 997:	8b 45 f0             	mov    -0x10(%ebp),%eax
 99a:	0f b6 00             	movzbl (%eax),%eax
 99d:	0f be c0             	movsbl %al,%eax
 9a0:	83 e8 30             	sub    $0x30,%eax
 9a3:	01 d0                	add    %edx,%eax
 9a5:	89 45 e8             	mov    %eax,-0x18(%ebp)
                fmt_ptr++;
 9a8:	48                   	dec    %eax
 9a9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
            while (*fmt_ptr >= '0' && *fmt_ptr <= '9') {
 9ad:	48                   	dec    %eax
 9ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
 9b1:	0f b6 00             	movzbl (%eax),%eax
 9b4:	3c 2f                	cmp    $0x2f,%al
 9b6:	7e 0b                	jle    9c3 <vsnprintf+0xe0>
 9b8:	48                   	dec    %eax
 9b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 9bc:	0f b6 00             	movzbl (%eax),%eax
 9bf:	3c 39                	cmp    $0x39,%al
 9c1:	7e c5                	jle    988 <vsnprintf+0xa5>
            }

            // 解析格式化符号
            switch (*fmt_ptr) {
 9c3:	48                   	dec    %eax
 9c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 9c7:	0f b6 00             	movzbl (%eax),%eax
 9ca:	0f be c0             	movsbl %al,%eax
 9cd:	83 f8 78             	cmp    $0x78,%eax
 9d0:	0f 84 a2 00 00 00    	je     a78 <vsnprintf+0x195>
 9d6:	83 f8 78             	cmp    $0x78,%eax
 9d9:	0f 8f c2 01 00 00    	jg     ba1 <vsnprintf+0x2be>
 9df:	83 f8 73             	cmp    $0x73,%eax
 9e2:	0f 84 05 01 00 00    	je     aed <vsnprintf+0x20a>
 9e8:	83 f8 73             	cmp    $0x73,%eax
 9eb:	0f 8f b0 01 00 00    	jg     ba1 <vsnprintf+0x2be>
 9f1:	83 f8 63             	cmp    $0x63,%eax
 9f4:	0f 84 77 01 00 00    	je     b71 <vsnprintf+0x28e>
 9fa:	83 f8 64             	cmp    $0x64,%eax
 9fd:	0f 85 9e 01 00 00    	jne    ba1 <vsnprintf+0x2be>
                case 'd': {
                    int num = va_arg(args, int);
 a03:	48                   	dec    %eax
 a04:	83 45 80 08          	addl   $0x8,-0x80(%ebp)
 a08:	48                   	dec    %eax
 a09:	8b 45 80             	mov    -0x80(%ebp),%eax
 a0c:	8b 40 f8             	mov    -0x8(%eax),%eax
 a0f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
                    char temp_buf[32];
                    itoa_with_padding(temp_buf, num, 10, width, zero_padding);
 a12:	8b 75 c4             	mov    -0x3c(%ebp),%esi
 a15:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 a18:	8b 55 e8             	mov    -0x18(%ebp),%edx
 a1b:	48                   	dec    %eax
 a1c:	8d 45 a0             	lea    -0x60(%ebp),%eax
 a1f:	41                   	inc    %ecx
 a20:	89 c8                	mov    %ecx,%eax
 a22:	89 d1                	mov    %edx,%ecx
 a24:	ba 0a 00 00 00       	mov    $0xa,%edx
 a29:	48                   	dec    %eax
 a2a:	89 c7                	mov    %eax,%edi
 a2c:	e8 aa f9 ff ff       	call   3db <itoa_with_padding>
                    int len = strlen(temp_buf);
 a31:	48                   	dec    %eax
 a32:	8d 45 a0             	lea    -0x60(%ebp),%eax
 a35:	48                   	dec    %eax
 a36:	89 c7                	mov    %eax,%edi
 a38:	e8 00 00 00 00       	call   a3d <vsnprintf+0x15a>
			a39: R_X86_64_PLT32	strlen-0x4
 a3d:	89 45 e0             	mov    %eax,-0x20(%ebp)

                    if (len > remaining) {
 a40:	8b 45 e0             	mov    -0x20(%ebp),%eax
 a43:	3b 45 ec             	cmp    -0x14(%ebp),%eax
 a46:	7e 06                	jle    a4e <vsnprintf+0x16b>
                        len = remaining;  // 截断
 a48:	8b 45 ec             	mov    -0x14(%ebp),%eax
 a4b:	89 45 e0             	mov    %eax,-0x20(%ebp)
                    }
                    strncpy(buf_ptr, temp_buf, len);
 a4e:	8b 55 e0             	mov    -0x20(%ebp),%edx
 a51:	48                   	dec    %eax
 a52:	8d 4d a0             	lea    -0x60(%ebp),%ecx
 a55:	48                   	dec    %eax
 a56:	8b 45 f8             	mov    -0x8(%ebp),%eax
 a59:	48                   	dec    %eax
 a5a:	89 ce                	mov    %ecx,%esi
 a5c:	48                   	dec    %eax
 a5d:	89 c7                	mov    %eax,%edi
 a5f:	e8 00 00 00 00       	call   a64 <vsnprintf+0x181>
			a60: R_X86_64_PLT32	strncpy-0x4
                    buf_ptr += len;
 a64:	8b 45 e0             	mov    -0x20(%ebp),%eax
 a67:	48                   	dec    %eax
 a68:	98                   	cwtl   
 a69:	48                   	dec    %eax
 a6a:	01 45 f8             	add    %eax,-0x8(%ebp)
                    remaining -= len;
 a6d:	8b 45 e0             	mov    -0x20(%ebp),%eax
 a70:	29 45 ec             	sub    %eax,-0x14(%ebp)
                    break;
 a73:	e9 4e 01 00 00       	jmp    bc6 <vsnprintf+0x2e3>
                }
                case 'x': {
                    unsigned int num = va_arg(args, unsigned int);
 a78:	48                   	dec    %eax
 a79:	83 45 80 08          	addl   $0x8,-0x80(%ebp)
 a7d:	48                   	dec    %eax
 a7e:	8b 45 80             	mov    -0x80(%ebp),%eax
 a81:	8b 40 f8             	mov    -0x8(%eax),%eax
 a84:	89 45 d4             	mov    %eax,-0x2c(%ebp)
                    char temp_buf[32];
                    itoa_with_padding(temp_buf, num, 16, width, zero_padding);
 a87:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 a8a:	8b 55 e8             	mov    -0x18(%ebp),%edx
 a8d:	8b 75 d4             	mov    -0x2c(%ebp),%esi
 a90:	48                   	dec    %eax
 a91:	8d 45 a0             	lea    -0x60(%ebp),%eax
 a94:	41                   	inc    %ecx
 a95:	89 c8                	mov    %ecx,%eax
 a97:	89 d1                	mov    %edx,%ecx
 a99:	ba 10 00 00 00       	mov    $0x10,%edx
 a9e:	48                   	dec    %eax
 a9f:	89 c7                	mov    %eax,%edi
 aa1:	e8 35 f9 ff ff       	call   3db <itoa_with_padding>
                    int len = strlen(temp_buf);
 aa6:	48                   	dec    %eax
 aa7:	8d 45 a0             	lea    -0x60(%ebp),%eax
 aaa:	48                   	dec    %eax
 aab:	89 c7                	mov    %eax,%edi
 aad:	e8 00 00 00 00       	call   ab2 <vsnprintf+0x1cf>
			aae: R_X86_64_PLT32	strlen-0x4
 ab2:	89 45 dc             	mov    %eax,-0x24(%ebp)

                    if (len > remaining) {
 ab5:	8b 45 dc             	mov    -0x24(%ebp),%eax
 ab8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
 abb:	7e 06                	jle    ac3 <vsnprintf+0x1e0>
                        len = remaining;  // 截断
 abd:	8b 45 ec             	mov    -0x14(%ebp),%eax
 ac0:	89 45 dc             	mov    %eax,-0x24(%ebp)
                    }
                    strncpy(buf_ptr, temp_buf, len);
 ac3:	8b 55 dc             	mov    -0x24(%ebp),%edx
 ac6:	48                   	dec    %eax
 ac7:	8d 4d a0             	lea    -0x60(%ebp),%ecx
 aca:	48                   	dec    %eax
 acb:	8b 45 f8             	mov    -0x8(%ebp),%eax
 ace:	48                   	dec    %eax
 acf:	89 ce                	mov    %ecx,%esi
 ad1:	48                   	dec    %eax
 ad2:	89 c7                	mov    %eax,%edi
 ad4:	e8 00 00 00 00       	call   ad9 <vsnprintf+0x1f6>
			ad5: R_X86_64_PLT32	strncpy-0x4
                    buf_ptr += len;
 ad9:	8b 45 dc             	mov    -0x24(%ebp),%eax
 adc:	48                   	dec    %eax
 add:	98                   	cwtl   
 ade:	48                   	dec    %eax
 adf:	01 45 f8             	add    %eax,-0x8(%ebp)
                    remaining -= len;
 ae2:	8b 45 dc             	mov    -0x24(%ebp),%eax
 ae5:	29 45 ec             	sub    %eax,-0x14(%ebp)
                    break;
 ae8:	e9 d9 00 00 00       	jmp    bc6 <vsnprintf+0x2e3>
                }
                case 's': {
                    const char *str = va_arg(args, const char *);
 aed:	48                   	dec    %eax
 aee:	83 45 80 08          	addl   $0x8,-0x80(%ebp)
 af2:	48                   	dec    %eax
 af3:	8b 45 80             	mov    -0x80(%ebp),%eax
 af6:	48                   	dec    %eax
 af7:	8b 40 f8             	mov    -0x8(%eax),%eax
 afa:	48                   	dec    %eax
 afb:	89 45 c8             	mov    %eax,-0x38(%ebp)
                    int len = strlen(str);
 afe:	48                   	dec    %eax
 aff:	8b 45 c8             	mov    -0x38(%ebp),%eax
 b02:	48                   	dec    %eax
 b03:	89 c7                	mov    %eax,%edi
 b05:	e8 00 00 00 00       	call   b0a <vsnprintf+0x227>
			b06: R_X86_64_PLT32	strlen-0x4
 b0a:	89 45 d8             	mov    %eax,-0x28(%ebp)

                    // 填充宽度
                    if (width > len) {
 b0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 b10:	3b 45 d8             	cmp    -0x28(%ebp),%eax
 b13:	7e 27                	jle    b3c <vsnprintf+0x259>
                        while (len < width && remaining > 0) {
 b15:	eb 17                	jmp    b2e <vsnprintf+0x24b>
                            *buf_ptr++ = ' ';
 b17:	48                   	dec    %eax
 b18:	8b 45 f8             	mov    -0x8(%ebp),%eax
 b1b:	48                   	dec    %eax
 b1c:	8d 50 01             	lea    0x1(%eax),%edx
 b1f:	48                   	dec    %eax
 b20:	89 55 f8             	mov    %edx,-0x8(%ebp)
 b23:	c6 00 20             	movb   $0x20,(%eax)
                            remaining--;
 b26:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
                            len++;
 b2a:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
                        while (len < width && remaining > 0) {
 b2e:	8b 45 d8             	mov    -0x28(%ebp),%eax
 b31:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 b34:	7d 06                	jge    b3c <vsnprintf+0x259>
 b36:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 b3a:	7f db                	jg     b17 <vsnprintf+0x234>
                        }
                    }

                    if (len > remaining) {
 b3c:	8b 45 d8             	mov    -0x28(%ebp),%eax
 b3f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
 b42:	7e 06                	jle    b4a <vsnprintf+0x267>
                        len = remaining;  // 截断
 b44:	8b 45 ec             	mov    -0x14(%ebp),%eax
 b47:	89 45 d8             	mov    %eax,-0x28(%ebp)
                    }
                    strncpy(buf_ptr, str, len);
 b4a:	8b 55 d8             	mov    -0x28(%ebp),%edx
 b4d:	48                   	dec    %eax
 b4e:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 b51:	48                   	dec    %eax
 b52:	8b 45 f8             	mov    -0x8(%ebp),%eax
 b55:	48                   	dec    %eax
 b56:	89 ce                	mov    %ecx,%esi
 b58:	48                   	dec    %eax
 b59:	89 c7                	mov    %eax,%edi
 b5b:	e8 00 00 00 00       	call   b60 <vsnprintf+0x27d>
			b5c: R_X86_64_PLT32	strncpy-0x4
                    buf_ptr += len;
 b60:	8b 45 d8             	mov    -0x28(%ebp),%eax
 b63:	48                   	dec    %eax
 b64:	98                   	cwtl   
 b65:	48                   	dec    %eax
 b66:	01 45 f8             	add    %eax,-0x8(%ebp)
                    remaining -= len;
 b69:	8b 45 d8             	mov    -0x28(%ebp),%eax
 b6c:	29 45 ec             	sub    %eax,-0x14(%ebp)
                    break;
 b6f:	eb 55                	jmp    bc6 <vsnprintf+0x2e3>
                }
                case 'c': {
                    char c = (char) va_arg(args, int);
 b71:	48                   	dec    %eax
 b72:	83 45 80 08          	addl   $0x8,-0x80(%ebp)
 b76:	48                   	dec    %eax
 b77:	8b 45 80             	mov    -0x80(%ebp),%eax
 b7a:	48                   	dec    %eax
 b7b:	83 e8 08             	sub    $0x8,%eax
 b7e:	8b 00                	mov    (%eax),%eax
 b80:	88 45 c3             	mov    %al,-0x3d(%ebp)
                    if (remaining > 0) {
 b83:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 b87:	7e 39                	jle    bc2 <vsnprintf+0x2df>
                        *buf_ptr++ = c;
 b89:	48                   	dec    %eax
 b8a:	8b 45 f8             	mov    -0x8(%ebp),%eax
 b8d:	48                   	dec    %eax
 b8e:	8d 50 01             	lea    0x1(%eax),%edx
 b91:	48                   	dec    %eax
 b92:	89 55 f8             	mov    %edx,-0x8(%ebp)
 b95:	0f b6 55 c3          	movzbl -0x3d(%ebp),%edx
 b99:	88 10                	mov    %dl,(%eax)
                        remaining--;
 b9b:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
                    }
                    break;
 b9f:	eb 21                	jmp    bc2 <vsnprintf+0x2df>
                }
                default: {
                    if (remaining > 0) {
 ba1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 ba5:	7e 1e                	jle    bc5 <vsnprintf+0x2e2>
                        *buf_ptr++ = *fmt_ptr;
 ba7:	48                   	dec    %eax
 ba8:	8b 45 f8             	mov    -0x8(%ebp),%eax
 bab:	48                   	dec    %eax
 bac:	8d 50 01             	lea    0x1(%eax),%edx
 baf:	48                   	dec    %eax
 bb0:	89 55 f8             	mov    %edx,-0x8(%ebp)
 bb3:	48                   	dec    %eax
 bb4:	8b 55 f0             	mov    -0x10(%ebp),%edx
 bb7:	0f b6 12             	movzbl (%edx),%edx
 bba:	88 10                	mov    %dl,(%eax)
                        remaining--;
 bbc:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
                    }
                    break;
 bc0:	eb 03                	jmp    bc5 <vsnprintf+0x2e2>
                    break;
 bc2:	90                   	nop
 bc3:	eb 22                	jmp    be7 <vsnprintf+0x304>
                    break;
 bc5:	90                   	nop
        if (*fmt_ptr == '%' && *(fmt_ptr + 1) != '%') {
 bc6:	eb 1f                	jmp    be7 <vsnprintf+0x304>
                }
            }
        } else {
            if (remaining > 0) {
 bc8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 bcc:	7e 19                	jle    be7 <vsnprintf+0x304>
                *buf_ptr++ = *fmt_ptr;
 bce:	48                   	dec    %eax
 bcf:	8b 45 f8             	mov    -0x8(%ebp),%eax
 bd2:	48                   	dec    %eax
 bd3:	8d 50 01             	lea    0x1(%eax),%edx
 bd6:	48                   	dec    %eax
 bd7:	89 55 f8             	mov    %edx,-0x8(%ebp)
 bda:	48                   	dec    %eax
 bdb:	8b 55 f0             	mov    -0x10(%ebp),%edx
 bde:	0f b6 12             	movzbl (%edx),%edx
 be1:	88 10                	mov    %dl,(%eax)
                remaining--;
 be3:	83 6d ec 01          	subl   $0x1,-0x14(%ebp)
            }
        }
        fmt_ptr++;
 be7:	48                   	dec    %eax
 be8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    while (*fmt_ptr && remaining > 0) {
 bec:	48                   	dec    %eax
 bed:	8b 45 f0             	mov    -0x10(%ebp),%eax
 bf0:	0f b6 00             	movzbl (%eax),%eax
 bf3:	84 c0                	test   %al,%al
 bf5:	74 0a                	je     c01 <vsnprintf+0x31e>
 bf7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 bfb:	0f 8f 39 fd ff ff    	jg     93a <vsnprintf+0x57>
    }

    *buf_ptr = '\0';  // 确保字符串以 NULL 结尾
 c01:	48                   	dec    %eax
 c02:	8b 45 f8             	mov    -0x8(%ebp),%eax
 c05:	c6 00 00             	movb   $0x0,(%eax)

    // 返回写入缓冲区的字节数
    return (int)(buf_ptr - buffer);
 c08:	48                   	dec    %eax
 c09:	8b 45 f8             	mov    -0x8(%ebp),%eax
 c0c:	48                   	dec    %eax
 c0d:	2b 45 98             	sub    -0x68(%ebp),%eax
}
 c10:	c9                   	leave  
 c11:	c3                   	ret    

0000000000000c12 <strchr>:
char* strchr(const char *str, int c) {
 c12:	f3 0f 1e fa          	endbr64 
 c16:	55                   	push   %ebp
 c17:	48                   	dec    %eax
 c18:	89 e5                	mov    %esp,%ebp
 c1a:	48                   	dec    %eax
 c1b:	89 7d e8             	mov    %edi,-0x18(%ebp)
 c1e:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    // 将字符 c 转换为 char 类型
    char target = (char)c;
 c21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 c24:	88 45 ff             	mov    %al,-0x1(%ebp)

    // 遍历字符串，直到找到目标字符或到达字符串结尾
    while (*str) {
 c27:	eb 17                	jmp    c40 <strchr+0x2e>
        if (*str == target) {
 c29:	48                   	dec    %eax
 c2a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 c2d:	0f b6 00             	movzbl (%eax),%eax
 c30:	38 45 ff             	cmp    %al,-0x1(%ebp)
 c33:	75 06                	jne    c3b <strchr+0x29>
            return (char*)str;
 c35:	48                   	dec    %eax
 c36:	8b 45 e8             	mov    -0x18(%ebp),%eax
 c39:	eb 15                	jmp    c50 <strchr+0x3e>
        }
        str++;
 c3b:	48                   	dec    %eax
 c3c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    while (*str) {
 c40:	48                   	dec    %eax
 c41:	8b 45 e8             	mov    -0x18(%ebp),%eax
 c44:	0f b6 00             	movzbl (%eax),%eax
 c47:	84 c0                	test   %al,%al
 c49:	75 de                	jne    c29 <strchr+0x17>
    }

    // 如果没找到目标字符，返回 NULL
    return NULL;
 c4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
 c50:	5d                   	pop    %ebp
 c51:	c3                   	ret    

0000000000000c52 <strtok>:

char* strtok(char *str, const char *delim) {
 c52:	f3 0f 1e fa          	endbr64 
 c56:	55                   	push   %ebp
 c57:	48                   	dec    %eax
 c58:	89 e5                	mov    %esp,%ebp
 c5a:	48                   	dec    %eax
 c5b:	83 ec 20             	sub    $0x20,%esp
 c5e:	48                   	dec    %eax
 c5f:	89 7d e8             	mov    %edi,-0x18(%ebp)
 c62:	48                   	dec    %eax
 c63:	89 75 e0             	mov    %esi,-0x20(%ebp)
    static char *current_pos = NULL;
    
    // 如果传入一个新的字符串，更新 current_pos 指针
    if (str != NULL) {
 c66:	48                   	dec    %eax
 c67:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 c6b:	74 0b                	je     c78 <strtok+0x26>
        current_pos = str;
 c6d:	48                   	dec    %eax
 c6e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 c71:	48                   	dec    %eax
 c72:	89 05 00 00 00 00    	mov    %eax,0x0
			c74: R_X86_64_PC32	.bss+0x3fc
    }
    
    // 如果当前字符串已经处理完，返回 NULL
    if (current_pos == NULL || *current_pos == '\0') {
 c78:	48                   	dec    %eax
 c79:	8b 05 00 00 00 00    	mov    0x0,%eax
			c7b: R_X86_64_PC32	.bss+0x3fc
 c7f:	48                   	dec    %eax
 c80:	85 c0                	test   %eax,%eax
 c82:	74 0e                	je     c92 <strtok+0x40>
 c84:	48                   	dec    %eax
 c85:	8b 05 00 00 00 00    	mov    0x0,%eax
			c87: R_X86_64_PC32	.bss+0x3fc
 c8b:	0f b6 00             	movzbl (%eax),%eax
 c8e:	84 c0                	test   %al,%al
 c90:	75 1c                	jne    cae <strtok+0x5c>
        return NULL;
 c92:	b8 00 00 00 00       	mov    $0x0,%eax
 c97:	e9 d0 00 00 00       	jmp    d6c <strtok+0x11a>
    }
    
    // 跳过分隔符
    while (*current_pos && strchr(delim, *current_pos)) {
        current_pos++;
 c9c:	48                   	dec    %eax
 c9d:	8b 05 00 00 00 00    	mov    0x0,%eax
			c9f: R_X86_64_PC32	.bss+0x3fc
 ca3:	48                   	dec    %eax
 ca4:	83 c0 01             	add    $0x1,%eax
 ca7:	48                   	dec    %eax
 ca8:	89 05 00 00 00 00    	mov    %eax,0x0
			caa: R_X86_64_PC32	.bss+0x3fc
    while (*current_pos && strchr(delim, *current_pos)) {
 cae:	48                   	dec    %eax
 caf:	8b 05 00 00 00 00    	mov    0x0,%eax
			cb1: R_X86_64_PC32	.bss+0x3fc
 cb5:	0f b6 00             	movzbl (%eax),%eax
 cb8:	84 c0                	test   %al,%al
 cba:	74 20                	je     cdc <strtok+0x8a>
 cbc:	48                   	dec    %eax
 cbd:	8b 05 00 00 00 00    	mov    0x0,%eax
			cbf: R_X86_64_PC32	.bss+0x3fc
 cc3:	0f b6 00             	movzbl (%eax),%eax
 cc6:	0f be d0             	movsbl %al,%edx
 cc9:	48                   	dec    %eax
 cca:	8b 45 e0             	mov    -0x20(%ebp),%eax
 ccd:	89 d6                	mov    %edx,%esi
 ccf:	48                   	dec    %eax
 cd0:	89 c7                	mov    %eax,%edi
 cd2:	e8 00 00 00 00       	call   cd7 <strtok+0x85>
			cd3: R_X86_64_PLT32	strchr-0x4
 cd7:	48                   	dec    %eax
 cd8:	85 c0                	test   %eax,%eax
 cda:	75 c0                	jne    c9c <strtok+0x4a>
    }

    // 如果到达了字符串末尾，返回 NULL
    if (*current_pos == '\0') {
 cdc:	48                   	dec    %eax
 cdd:	8b 05 00 00 00 00    	mov    0x0,%eax
			cdf: R_X86_64_PC32	.bss+0x3fc
 ce3:	0f b6 00             	movzbl (%eax),%eax
 ce6:	84 c0                	test   %al,%al
 ce8:	75 07                	jne    cf1 <strtok+0x9f>
        return NULL;
 cea:	b8 00 00 00 00       	mov    $0x0,%eax
 cef:	eb 7b                	jmp    d6c <strtok+0x11a>
    }

    // 标记单词的开始位置
    char *start = current_pos;
 cf1:	48                   	dec    %eax
 cf2:	8b 05 00 00 00 00    	mov    0x0,%eax
			cf4: R_X86_64_PC32	.bss+0x3fc
 cf8:	48                   	dec    %eax
 cf9:	89 45 f8             	mov    %eax,-0x8(%ebp)

    // 找到下一个分隔符并将其替换为 '\0'
    while (*current_pos && !strchr(delim, *current_pos)) {
 cfc:	eb 12                	jmp    d10 <strtok+0xbe>
        current_pos++;
 cfe:	48                   	dec    %eax
 cff:	8b 05 00 00 00 00    	mov    0x0,%eax
			d01: R_X86_64_PC32	.bss+0x3fc
 d05:	48                   	dec    %eax
 d06:	83 c0 01             	add    $0x1,%eax
 d09:	48                   	dec    %eax
 d0a:	89 05 00 00 00 00    	mov    %eax,0x0
			d0c: R_X86_64_PC32	.bss+0x3fc
    while (*current_pos && !strchr(delim, *current_pos)) {
 d10:	48                   	dec    %eax
 d11:	8b 05 00 00 00 00    	mov    0x0,%eax
			d13: R_X86_64_PC32	.bss+0x3fc
 d17:	0f b6 00             	movzbl (%eax),%eax
 d1a:	84 c0                	test   %al,%al
 d1c:	74 20                	je     d3e <strtok+0xec>
 d1e:	48                   	dec    %eax
 d1f:	8b 05 00 00 00 00    	mov    0x0,%eax
			d21: R_X86_64_PC32	.bss+0x3fc
 d25:	0f b6 00             	movzbl (%eax),%eax
 d28:	0f be d0             	movsbl %al,%edx
 d2b:	48                   	dec    %eax
 d2c:	8b 45 e0             	mov    -0x20(%ebp),%eax
 d2f:	89 d6                	mov    %edx,%esi
 d31:	48                   	dec    %eax
 d32:	89 c7                	mov    %eax,%edi
 d34:	e8 00 00 00 00       	call   d39 <strtok+0xe7>
			d35: R_X86_64_PLT32	strchr-0x4
 d39:	48                   	dec    %eax
 d3a:	85 c0                	test   %eax,%eax
 d3c:	74 c0                	je     cfe <strtok+0xac>
    }

    if (*current_pos != '\0') {
 d3e:	48                   	dec    %eax
 d3f:	8b 05 00 00 00 00    	mov    0x0,%eax
			d41: R_X86_64_PC32	.bss+0x3fc
 d45:	0f b6 00             	movzbl (%eax),%eax
 d48:	84 c0                	test   %al,%al
 d4a:	74 1c                	je     d68 <strtok+0x116>
        *current_pos = '\0';
 d4c:	48                   	dec    %eax
 d4d:	8b 05 00 00 00 00    	mov    0x0,%eax
			d4f: R_X86_64_PC32	.bss+0x3fc
 d53:	c6 00 00             	movb   $0x0,(%eax)
        current_pos++;
 d56:	48                   	dec    %eax
 d57:	8b 05 00 00 00 00    	mov    0x0,%eax
			d59: R_X86_64_PC32	.bss+0x3fc
 d5d:	48                   	dec    %eax
 d5e:	83 c0 01             	add    $0x1,%eax
 d61:	48                   	dec    %eax
 d62:	89 05 00 00 00 00    	mov    %eax,0x0
			d64: R_X86_64_PC32	.bss+0x3fc
    }

    return start;
 d68:	48                   	dec    %eax
 d69:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 d6c:	c9                   	leave  
 d6d:	c3                   	ret    
