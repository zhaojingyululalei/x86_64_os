# 进入64位内核
## 一.cpu检测，是否支持64位
    1. 检查cpuid指令，该指令可以获取cpu支持的一些功能
    2. 执行cpuid指令
        将eax寄存器置为1，然后执行cpuid指令，可以获取扩展处理器信息和特征
    3. 检查edx寄存器的第29位，如果置1，表示该cpu支持64位
    4. 检查扩展功能
        将eax寄存器置为0x80000000,然后执行cpuid，会返回cpu支持的最大功能号，返回值存在eax中
    5. 检查扩展功能特性
        检查edx第29位是否置1，置1表示cpu支持64位
    注：只能检测一部分基础信息，例如cpu品牌等等。如果要获取cpu数量，大端小端，缓存，NUMA节点,是否支持VT等信息，通过ACPI检测

## 二.进入IA32-E兼容模式
    1.启用cr4寄存器的PAE位，(物理地址扩展位)
    2.启用IA32_EFER寄存器的LME位(长模式使能位)
    3.加载并激活4级页表，(cpu可能会支持5级页表，但是在之前得检查是否支持5级页表)，4级页表肯定支持
    4.跳转到兼容模式

## 三.64位内存
    1.32位虚拟和物理内存只有4G
        假如如果32位系统有64G的内存，需要开启PAE，因此还是需要分段的。
        因此32位下有两种分页机制
            10 10 12分页 32位os就用的这种 适用于内存小于4G的
            PAE(物理地址扩展)分页 29912分页 适用于内存大于4G的,最大能支持64G物理内存(注：虚拟内存仍然是4G)

    2.64位模式下，分段这个机制就彻底被抛弃了
        64位模式下就是用平摊模型，48根地址线，可访问256T的内存
        在段描述符中，base和limit字段作废(段界限)，基地址就是0，而且没有界限，其他的如DPL之类的位还是有用的
    3.虚拟内存相关硬件
        MMU：虚拟内存到物理内存之间的映射
        TLB：比如有一部分内存经常访问，就会保存在TLB中。不用每次都去MMU里映射，效率会更高

## 四.寄存器方面的变化
    1. gdtr idtr  他们的gdt表首地址长度变成8B，limit还是2字节，总共变成了10B，原来是段表基地址4B，limit2B，共6B
    2. 多了一些64位专属寄存器，例如IA32e_EFER寄存器，用来开启IA32e模式的，以及允许syscall 和 sysret指令

## 五.NUMA架构
    1.UMA架构：多个cpu访问内存，不分节点
    2.NUMA架构：将整个系统划分为多个节点，例如1号2号cpu访问区域1的内存，这个部分构成一个节点。然后整个系统分为多个这种NUMA节点。